// automatically generated by the FlatBuffers compiler, do not modify

package LeagueToolkit.IO.ReleaseManifestFile

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class ReleaseManifestBody : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ReleaseManifestBody {
        __init(_i, _bb)
        return this
    }
    fun bundles(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestBundle? = bundles(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestBundle(), j)
    fun bundles(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestBundle, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestBundle? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val bundlesLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    fun languages(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestLanguage? = languages(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestLanguage(), j)
    fun languages(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestLanguage, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestLanguage? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val languagesLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    fun files(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestFile? = files(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestFile(), j)
    fun files(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestFile, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestFile? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val filesLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    fun directories(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestDirectory? = directories(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestDirectory(), j)
    fun directories(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestDirectory, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestDirectory? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val directoriesLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    fun encryptionKeys(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestEncryptionKey? = encryptionKeys(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestEncryptionKey(), j)
    fun encryptionKeys(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestEncryptionKey, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestEncryptionKey? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val encryptionKeysLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    fun chunkingParameters(j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestChunkingParameter? = chunkingParameters(LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestChunkingParameter(), j)
    fun chunkingParameters(obj: LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestChunkingParameter, j: Int) : LeagueToolkit.IO.ReleaseManifestFile.ReleaseManifestChunkingParameter? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val chunkingParametersLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsReleaseManifestBody(_bb: ByteBuffer): ReleaseManifestBody = getRootAsReleaseManifestBody(_bb, ReleaseManifestBody())
        fun getRootAsReleaseManifestBody(_bb: ByteBuffer, obj: ReleaseManifestBody): ReleaseManifestBody {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createReleaseManifestBody(builder: FlatBufferBuilder, bundlesOffset: Int, languagesOffset: Int, filesOffset: Int, directoriesOffset: Int, encryptionKeysOffset: Int, chunkingParametersOffset: Int) : Int {
            builder.startTable(6)
            addChunkingParameters(builder, chunkingParametersOffset)
            addEncryptionKeys(builder, encryptionKeysOffset)
            addDirectories(builder, directoriesOffset)
            addFiles(builder, filesOffset)
            addLanguages(builder, languagesOffset)
            addBundles(builder, bundlesOffset)
            return endReleaseManifestBody(builder)
        }
        fun startReleaseManifestBody(builder: FlatBufferBuilder) = builder.startTable(6)
        fun addBundles(builder: FlatBufferBuilder, bundles: Int) = builder.addOffset(0, bundles, 0)
        fun createBundlesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startBundlesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLanguages(builder: FlatBufferBuilder, languages: Int) = builder.addOffset(1, languages, 0)
        fun createLanguagesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLanguagesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFiles(builder: FlatBufferBuilder, files: Int) = builder.addOffset(2, files, 0)
        fun createFilesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFilesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDirectories(builder: FlatBufferBuilder, directories: Int) = builder.addOffset(3, directories, 0)
        fun createDirectoriesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDirectoriesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEncryptionKeys(builder: FlatBufferBuilder, encryptionKeys: Int) = builder.addOffset(4, encryptionKeys, 0)
        fun createEncryptionKeysVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEncryptionKeysVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addChunkingParameters(builder: FlatBufferBuilder, chunkingParameters: Int) = builder.addOffset(5, chunkingParameters, 0)
        fun createChunkingParametersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startChunkingParametersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endReleaseManifestBody(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
